package main

import (
	"fmt"
	"math/rand"
	"time"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/push"
)

var (
	completionTime = prometheus.NewGauge(prometheus.GaugeOpts{
		Name: "puar_job_completition_timestamp_seconds",
		Help: "The timestamp of the last successful completion.",
	})
	duration = prometheus.NewGauge(prometheus.GaugeOpts{
		Name: "puar_job_duration_seconds",
		Help: "The duration of the last job in seconds.",
	})
	maximal = prometheus.NewGauge(prometheus.GaugeOpts{
		Name: "puar_job_max_int",
		Help: "Maximal integer generated by the job",
	})
	minimal = prometheus.NewGauge(prometheus.GaugeOpts{
		Name: "puar_job_min_int",
		Help: "Minimal integer generated by the job",
	})
	average = prometheus.NewGauge(prometheus.GaugeOpts{
		Name: "puar_job_avg_int",
		Help: "Average integer generated by the job",
	})
)

func GenerateNumbers() {
	bound := 10000.0
	n := 1000
	min := bound
	max := 0.0
	sum := 0.0
	rand.Seed(time.Now().UnixNano())
	for i := 0; i < n; i++ {
		x := rand.Float64() * bound
		sum += x
		if x < min {
			min = x
		}
		if max < x {
			max = x
		}
		time.Sleep(time.Duration(rand.Float64()*300) * time.Millisecond)
	}
	avg := sum / float64(n)
	maximal.Set(max)
	minimal.Set(min)
	average.Set(avg)
}

func main() {
	startTime := time.Now()
	registry := prometheus.NewRegistry()
	registry.MustRegister(completionTime, duration, maximal, minimal, average)
	GenerateNumbers()
	endTime := time.Now()
	diff := float64(endTime.Sub(startTime).Seconds())
	duration.Set(diff)
	completionTime.SetToCurrentTime()
	pusher := push.New("http://pushgateway:9091", "puar_job").Gatherer(registry).Grouping("job", "puar")
	if err := pusher.Push(); err != nil {
		fmt.Println("Could not push completion time to Pushgateway:", err)
	}
}
